"use strict";
/**
 * Authorization Middleware - Phase 1.3
 *
 * Middleware functions and decorators for common authorization patterns.
 * Provides reusable authorization logic for Lambda handlers and services.
 *
 * Compliance:
 * - Phase 1.3 Spec: .kiro/specs/phase-1.3.authorization.foundation.v1.md
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateAuthContext = exports.authorizeIf = exports.authorizeRequest = exports.hasCapability = exports.createAuthorizationContext = exports.Authorize = exports.requireClubManagement = exports.requirePlatformManagement = exports.requireCapability = void 0;
const types_1 = require("./types");
const authorization_service_1 = require("./authorization-service");
const authorization_errors_1 = require("./authorization-errors");
/**
 * Create middleware that requires specific capability
 *
 * @param capability - Required system capability
 * @param resource - Optional resource identifier
 * @returns Authorization middleware function
 */
function requireCapability(capability, resource) {
    return async (authContext) => {
        const result = await authorization_service_1.authorizationService.authorize(authContext, capability, resource);
        if (!result.granted) {
            throw new authorization_errors_1.InsufficientPrivilegesError(capability, authContext.userId, resource);
        }
    };
}
exports.requireCapability = requireCapability;
/**
 * Create middleware that requires platform management privileges
 */
exports.requirePlatformManagement = requireCapability(types_1.SystemCapability.MANAGE_PLATFORM);
/**
 * Create middleware that requires club management privileges
 */
exports.requireClubManagement = requireCapability(types_1.SystemCapability.MANAGE_ALL_CLUBS);
/**
 * Authorization decorator for service methods
 *
 * @param capability - Required capability
 * @param resourceExtractor - Function to extract resource from method arguments
 */
function Authorize(capability, resourceExtractor) {
    return function (target, propertyKey, descriptor) {
        const originalMethod = descriptor.value;
        descriptor.value = async function (...args) {
            // Find AuthContext in arguments (should be last parameter by convention)
            const authContext = args.find(arg => arg && typeof arg === 'object' && 'isAuthenticated' in arg);
            if (!authContext) {
                throw new Error('AuthContext not found in method arguments');
            }
            // Extract resource if extractor provided
            const resource = resourceExtractor ? resourceExtractor(...args) : undefined;
            // Perform authorization check
            const result = await authorization_service_1.authorizationService.authorize(authContext, capability, resource);
            if (!result.granted) {
                throw new authorization_errors_1.InsufficientPrivilegesError(capability, authContext.userId, resource);
            }
            // Call original method
            return originalMethod.apply(this, args);
        };
        return descriptor;
    };
}
exports.Authorize = Authorize;
/**
 * Enhanced authorization context creator
 *
 * @param authContext - Base authentication context
 * @returns Enhanced authorization context
 */
async function createAuthorizationContext(authContext) {
    return await authorization_service_1.authorizationService.createAuthorizationContext(authContext);
}
exports.createAuthorizationContext = createAuthorizationContext;
/**
 * Quick capability check utility
 *
 * @param authContext - Authentication context
 * @param capability - Capability to check
 * @returns True if user has capability
 */
async function hasCapability(authContext, capability) {
    return await authorization_service_1.authorizationService.hasSystemCapability(authContext, capability);
}
exports.hasCapability = hasCapability;
/**
 * Authorization guard for Lambda handlers
 *
 * @param authContext - Authentication context
 * @param requiredCapabilities - Array of required capabilities (user needs at least one)
 * @param resource - Optional resource identifier
 * @throws InsufficientPrivilegesError if authorization fails
 */
async function authorizeRequest(authContext, requiredCapabilities, resource) {
    if (requiredCapabilities.length === 0) {
        return; // No authorization required
    }
    // Check if user has any of the required capabilities
    for (const capability of requiredCapabilities) {
        const hasCapability = await authorization_service_1.authorizationService.hasSystemCapability(authContext, capability);
        if (hasCapability) {
            return; // User has at least one required capability
        }
    }
    // User doesn't have any required capabilities
    const primaryCapability = requiredCapabilities[0];
    throw new authorization_errors_1.InsufficientPrivilegesError(primaryCapability, authContext.userId, resource);
}
exports.authorizeRequest = authorizeRequest;
/**
 * Conditional authorization - only check if condition is met
 *
 * @param condition - Condition to check
 * @param authContext - Authentication context
 * @param capability - Required capability if condition is true
 * @param resource - Optional resource identifier
 */
async function authorizeIf(condition, authContext, capability, resource) {
    if (condition) {
        await requireCapability(capability, resource)(authContext);
    }
}
exports.authorizeIf = authorizeIf;
/**
 * Authorization context validator
 *
 * @param authContext - Context to validate
 * @throws Error if context is invalid
 */
function validateAuthContext(authContext) {
    if (!authContext) {
        throw new Error('AuthContext is required');
    }
    if (!authContext.isAuthenticated) {
        throw new Error('User must be authenticated');
    }
    if (!authContext.userId) {
        throw new Error('User ID is required');
    }
    if (!authContext.systemRole) {
        throw new Error('System role is required');
    }
}
exports.validateAuthContext = validateAuthContext;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0aG9yaXphdGlvbi1taWRkbGV3YXJlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYXV0aG9yaXphdGlvbi1taWRkbGV3YXJlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7Ozs7R0FRRzs7O0FBR0gsbUNBQWlFO0FBQ2pFLG1FQUErRDtBQUMvRCxpRUFBcUU7QUFRckU7Ozs7OztHQU1HO0FBQ0gsU0FBZ0IsaUJBQWlCLENBQy9CLFVBQTRCLEVBQzVCLFFBQWlCO0lBRWpCLE9BQU8sS0FBSyxFQUFFLFdBQXdCLEVBQWlCLEVBQUU7UUFDdkQsTUFBTSxNQUFNLEdBQUcsTUFBTSw0Q0FBb0IsQ0FBQyxTQUFTLENBQUMsV0FBVyxFQUFFLFVBQVUsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUV2RixJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sRUFBRTtZQUNuQixNQUFNLElBQUksa0RBQTJCLENBQUMsVUFBVSxFQUFFLFdBQVcsQ0FBQyxNQUFNLEVBQUUsUUFBUSxDQUFDLENBQUM7U0FDakY7SUFDSCxDQUFDLENBQUM7QUFDSixDQUFDO0FBWEQsOENBV0M7QUFFRDs7R0FFRztBQUNVLFFBQUEseUJBQXlCLEdBQUcsaUJBQWlCLENBQUMsd0JBQWdCLENBQUMsZUFBZSxDQUFDLENBQUM7QUFFN0Y7O0dBRUc7QUFDVSxRQUFBLHFCQUFxQixHQUFHLGlCQUFpQixDQUFDLHdCQUFnQixDQUFDLGdCQUFnQixDQUFDLENBQUM7QUFFMUY7Ozs7O0dBS0c7QUFDSCxTQUFnQixTQUFTLENBQ3ZCLFVBQTRCLEVBQzVCLGlCQUE4QztJQUU5QyxPQUFPLFVBQVUsTUFBVyxFQUFFLFdBQW1CLEVBQUUsVUFBOEI7UUFDL0UsTUFBTSxjQUFjLEdBQUcsVUFBVSxDQUFDLEtBQUssQ0FBQztRQUV4QyxVQUFVLENBQUMsS0FBSyxHQUFHLEtBQUssV0FBVyxHQUFHLElBQVc7WUFDL0MseUVBQXlFO1lBQ3pFLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxJQUFJ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LENBQUMsTUFBTSxFQUFFO1FBQ3ZCLE1BQU0sSUFBSSxLQUFLLENBQUMscUJBQXFCLENBQUMsQ0FBQztLQUN4QztJQUVELElBQUksQ0FBQyxXQUFXLENBQUMsVUFBVSxFQUFFO1FBQzNCLE1BQU0sSUFBSSxLQUFLLENBQUMseUJBQXlCLENBQUMsQ0FBQztLQUM1QztBQUNILENBQUM7QUFoQkQsa0RBZ0JDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBdXRob3JpemF0aW9uIE1pZGRsZXdhcmUgLSBQaGFzZSAxLjNcbiAqIFxuICogTWlkZGxld2FyZSBmdW5jdGlvbnMgYW5kIGRlY29yYXRvcnMgZm9yIGNvbW1vbiBhdXRob3JpemF0aW9uIHBhdHRlcm5zLlxuICogUHJvdmlkZXMgcmV1c2FibGUgYXV0aG9yaXphdGlvbiBsb2dpYyBmb3IgTGFtYmRhIGhhbmRsZXJzIGFuZCBzZXJ2aWNlcy5cbiAqIFxuICogQ29tcGxpYW5jZTpcbiAqIC0gUGhhc2UgMS4zIFNwZWM6IC5raXJvL3NwZWNzL3BoYXNlLTEuMy5hdXRob3JpemF0aW9uLmZvdW5kYXRpb24udjEubWRcbiAqL1xuXG5pbXBvcnQgeyBBdXRoQ29udGV4dCB9IGZyb20gJy4uL3R5cGVzL2F1dGgnO1xuaW1wb3J0IHsgU3lzdGVtQ2FwYWJpbGl0eSwgQXV0aG9yaXphdGlvbkNvbnRleHQgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IGF1dGhvcml6YXRpb25TZXJ2aWNlIH0gZnJvbSAnLi9hdXRob3JpemF0aW9uLXNlcnZpY2UnO1xuaW1wb3J0IHsgSW5zdWZmaWNpZW50UHJpdmlsZWdlc0Vycm9yIH0gZnJvbSAnLi9hdXRob3JpemF0aW9uLWVycm9ycyc7XG5pbXBvcnQgeyBBdXRob3JpemF0aW9uTG9nZ2VyIH0gZnJvbSAnLi9hdXRob3JpemF0aW9uLWxvZ2dlcic7XG5cbi8qKlxuICogQXV0aG9yaXphdGlvbiBtaWRkbGV3YXJlIGZ1bmN0aW9uIHR5cGVcbiAqL1xuZXhwb3J0IHR5cGUgQXV0aG9yaXphdGlvbk1pZGRsZXdhcmUgPSAoYXV0aENvbnRleHQ6IEF1dGhDb250ZXh0KSA9PiBQcm9taXNlPHZvaWQ+O1xuXG4vKipcbiAqIENyZWF0ZSBtaWRkbGV3YXJlIHRoYXQgcmVxdWlyZXMgc3BlY2lmaWMgY2FwYWJpbGl0eVxuICogXG4gKiBAcGFyYW0gY2FwYWJpbGl0eSAtIFJlcXVpcmVkIHN5c3RlbSBjYXBhYmlsaXR5XG4gKiBAcGFyYW0gcmVzb3VyY2UgLSBPcHRpb25hbCByZXNvdXJjZSBpZGVudGlmaWVyXG4gKiBAcmV0dXJucyBBdXRob3JpemF0aW9uIG1pZGRsZXdhcmUgZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlcXVpcmVDYXBhYmlsaXR5KFxuICBjYXBhYmlsaXR5OiBTeXN0ZW1DYXBhYmlsaXR5LFxuICByZXNvdXJjZT86IHN0cmluZ1xuKTogQXV0aG9yaXphdGlvbk1pZGRsZXdhcmUge1xuICByZXR1cm4gYXN5bmMgKGF1dGhDb250ZXh0OiBBdXRoQ29udGV4dCk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGF1dGhvcml6YXRpb25TZXJ2aWNlLmF1dGhvcml6ZShhdXRoQ29udGV4dCwgY2FwYWJpbGl0eSwgcmVzb3VyY2UpO1xuICAgIFxuICAgIGlmICghcmVzdWx0LmdyYW50ZWQpIHtcbiAgICAgIHRocm93IG5ldyBJbnN1ZmZpY2llbnRQcml2aWxlZ2VzRXJyb3IoY2FwYWJpbGl0eSwgYXV0aENvbnRleHQudXNlcklkLCByZXNvdXJjZSk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZSBtaWRkbGV3YXJlIHRoYXQgcmVxdWlyZXMgcGxhdGZvcm0gbWFuYWdlbWVudCBwcml2aWxlZ2VzXG4gKi9cbmV4cG9ydCBjb25zdCByZXF1aXJlUGxhdGZvcm1NYW5hZ2VtZW50ID0gcmVxdWlyZUNhcGFiaWxpdHkoU3lzdGVtQ2FwYWJpbGl0eS5NQU5BR0VfUExBVEZPUk0pO1xuXG4vKipcbiAqIENyZWF0ZSBtaWRkbGV3YXJlIHRoYXQgcmVxdWlyZXMgY2x1YiBtYW5hZ2VtZW50IHByaXZpbGVnZXNcbiAqL1xuZXhwb3J0IGNvbnN0IHJlcXVpcmVDbHViTWFuYWdlbWVudCA9IHJlcXVpcmVDYXBhYmlsaXR5KFN5c3RlbUNhcGFiaWxpdHkuTUFOQUdFX0FMTF9DTFVCUyk7XG5cbi8qKlxuICogQXV0aG9yaXphdGlvbiBkZWNvcmF0b3IgZm9yIHNlcnZpY2UgbWV0aG9kc1xuICogXG4gKiBAcGFyYW0gY2FwYWJpbGl0eSAtIFJlcXVpcmVkIGNhcGFiaWxpdHlcbiAqIEBwYXJhbSByZXNvdXJjZUV4dHJhY3RvciAtIEZ1bmN0aW9uIHRvIGV4dHJhY3QgcmVzb3VyY2UgZnJvbSBtZXRob2QgYXJndW1lbnRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBBdXRob3JpemUoXG4gIGNhcGFiaWxpdHk6IFN5c3RlbUNhcGFiaWxpdHksXG4gIHJlc291cmNlRXh0cmFjdG9yPzogKC4uLmFyZ3M6IGFueVtdKSA9PiBzdHJpbmdcbikge1xuICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldDogYW55LCBwcm9wZXJ0eUtleTogc3RyaW5nLCBkZXNjcmlwdG9yOiBQcm9wZXJ0eURlc2NyaXB0b3IpIHtcbiAgICBjb25zdCBvcmlnaW5hbE1ldGhvZCA9IGRlc2NyaXB0b3IudmFsdWU7XG4gICAgXG4gICAgZGVzY3JpcHRvci52YWx1ZSA9IGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzOiBhbnlbXSkge1xuICAgICAgLy8gRmluZCBBdXRoQ29udGV4dCBpbiBhcmd1bWVudHMgKHNob3VsZCBiZSBsYXN0IHBhcmFtZXRlciBieSBjb252ZW50aW9uKVxuICAgICAgY29uc3QgYXV0aENvbnRleHQgPSBhcmdzLmZpbmQoYXJnID0+IGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiAnaXNBdXRoZW50aWNhdGVkJyBpbiBhcmcpIGFzIEF1dGhDb250ZXh0O1xuICAgICAgXG4gICAgICBpZiAoIWF1dGhDb250ZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXV0aENvbnRleHQgbm90IGZvdW5kIGluIG1ldGhvZCBhcmd1bWVudHMnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRXh0cmFjdCByZXNvdXJjZSBpZiBleHRyYWN0b3IgcHJvdmlkZWRcbiAgICAgIGNvbnN0IHJlc291cmNlID0gcmVzb3VyY2VFeHRyYWN0b3IgPyByZXNvdXJjZUV4dHJhY3RvciguLi5hcmdzKSA6IHVuZGVmaW5lZDtcbiAgICAgIFxuICAgICAgLy8gUGVyZm9ybSBhdXRob3JpemF0aW9uIGNoZWNrXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhdXRob3JpemF0aW9uU2VydmljZS5hdXRob3JpemUoYXV0aENvbnRleHQsIGNhcGFiaWxpdHksIHJlc291cmNlKTtcbiAgICAgIFxuICAgICAgaWYgKCFyZXN1bHQuZ3JhbnRlZCkge1xuICAgICAgICB0aHJvdyBuZXcgSW5zdWZmaWNpZW50UHJpdmlsZWdlc0Vycm9yKGNhcGFiaWxpdHksIGF1dGhDb250ZXh0LnVzZXJJZCwgcmVzb3VyY2UpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDYWxsIG9yaWdpbmFsIG1ldGhvZFxuICAgICAgcmV0dXJuIG9yaWdpbmFsTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gIH07XG59XG5cbi8qKlxuICogRW5oYW5jZWQgYXV0aG9yaXphdGlvbiBjb250ZXh0IGNyZWF0b3JcbiAqIFxuICogQHBhcmFtIGF1dGhDb250ZXh0IC0gQmFzZSBhdXRoZW50aWNhdGlvbiBjb250ZXh0XG4gKiBAcmV0dXJucyBFbmhhbmNlZCBhdXRob3JpemF0aW9uIGNvbnRleHRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUF1dGhvcml6YXRpb25Db250ZXh0KGF1dGhDb250ZXh0OiBBdXRoQ29udGV4dCk6IFByb21pc2U8QXV0aG9yaXphdGlvbkNvbnRleHQ+IHtcbiAgcmV0dXJuIGF3YWl0IGF1dGhvcml6YXRpb25TZXJ2aWNlLmNyZWF0ZUF1dGhvcml6YXRpb25Db250ZXh0KGF1dGhDb250ZXh0KTtcbn1cblxuLyoqXG4gKiBRdWljayBjYXBhYmlsaXR5IGNoZWNrIHV0aWxpdHlcbiAqIFxuICogQHBhcmFtIGF1dGhDb250ZXh0IC0gQXV0aGVudGljYXRpb24gY29udGV4dFxuICogQHBhcmFtIGNhcGFiaWxpdHkgLSBDYXBhYmlsaXR5IHRvIGNoZWNrXG4gKiBAcmV0dXJucyBUcnVlIGlmIHVzZXIgaGFzIGNhcGFiaWxpdHlcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGhhc0NhcGFiaWxpdHkoXG4gIGF1dGhDb250ZXh0OiBBdXRoQ29udGV4dCxcbiAgY2FwYWJpbGl0eTogU3lzdGVtQ2FwYWJpbGl0eVxuKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIHJldHVybiBhd2FpdCBhdXRob3JpemF0aW9uU2VydmljZS5oYXNTeXN0ZW1DYXBhYmlsaXR5KGF1dGhDb250ZXh0LCBjYXBhYmlsaXR5KTtcbn1cblxuLyoqXG4gKiBBdXRob3JpemF0aW9uIGd1YXJkIGZvciBMYW1iZGEgaGFuZGxlcnNcbiAqIFxuICogQHBhcmFtIGF1dGhDb250ZXh0IC0gQXV0aGVudGljYXRpb24gY29udGV4dFxuICogQHBhcmFtIHJlcXVpcmVkQ2FwYWJpbGl0aWVzIC0gQXJyYXkgb2YgcmVxdWlyZWQgY2FwYWJpbGl0aWVzICh1c2VyIG5lZWRzIGF0IGxlYXN0IG9uZSlcbiAqIEBwYXJhbSByZXNvdXJjZSAtIE9wdGlvbmFsIHJlc291cmNlIGlkZW50aWZpZXJcbiAqIEB0aHJvd3MgSW5zdWZmaWNpZW50UHJpdmlsZWdlc0Vycm9yIGlmIGF1dGhvcml6YXRpb24gZmFpbHNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGF1dGhvcml6ZVJlcXVlc3QoXG4gIGF1dGhDb250ZXh0OiBBdXRoQ29udGV4dCxcbiAgcmVxdWlyZWRDYXBhYmlsaXRpZXM6IFN5c3RlbUNhcGFiaWxpdHlbXSxcbiAgcmVzb3VyY2U/OiBzdHJpbmdcbik6IFByb21pc2U8dm9pZD4ge1xuICBpZiAocmVxdWlyZWRDYXBhYmlsaXRpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuOyAvLyBObyBhdXRob3JpemF0aW9uIHJlcXVpcmVkXG4gIH1cbiAgXG4gIC8vIENoZWNrIGlmIHVzZXIgaGFzIGFueSBvZiB0aGUgcmVxdWlyZWQgY2FwYWJpbGl0aWVzXG4gIGZvciAoY29uc3QgY2FwYWJpbGl0eSBvZiByZXF1aXJlZENhcGFiaWxpdGllcykge1xuICAgIGNvbnN0IGhhc0NhcGFiaWxpdHkgPSBhd2FpdCBhdXRob3JpemF0aW9uU2VydmljZS5oYXNTeXN0ZW1DYXBhYmlsaXR5KGF1dGhDb250ZXh0LCBjYXBhYmlsaXR5KTtcbiAgICBpZiAoaGFzQ2FwYWJpbGl0eSkge1xuICAgICAgcmV0dXJuOyAvLyBVc2VyIGhhcyBhdCBsZWFzdCBvbmUgcmVxdWlyZWQgY2FwYWJpbGl0eVxuICAgIH1cbiAgfVxuICBcbiAgLy8gVXNlciBkb2Vzbid0IGhhdmUgYW55IHJlcXVpcmVkIGNhcGFiaWxpdGllc1xuICBjb25zdCBwcmltYXJ5Q2FwYWJpbGl0eSA9IHJlcXVpcmVkQ2FwYWJpbGl0aWVzWzBdO1xuICB0aHJvdyBuZXcgSW5zdWZmaWNpZW50UHJpdmlsZWdlc0Vycm9yKHByaW1hcnlDYXBhYmlsaXR5LCBhdXRoQ29udGV4dC51c2VySWQsIHJlc291cmNlKTtcbn1cblxuLyoqXG4gKiBDb25kaXRpb25hbCBhdXRob3JpemF0aW9uIC0gb25seSBjaGVjayBpZiBjb25kaXRpb24gaXMgbWV0XG4gKiBcbiAqIEBwYXJhbSBjb25kaXRpb24gLSBDb25kaXRpb24gdG8gY2hlY2tcbiAqIEBwYXJhbSBhdXRoQ29udGV4dCAtIEF1dGhlbnRpY2F0aW9uIGNvbnRleHRcbiAqIEBwYXJhbSBjYXBhYmlsaXR5IC0gUmVxdWlyZWQgY2FwYWJpbGl0eSBpZiBjb25kaXRpb24gaXMgdHJ1ZVxuICogQHBhcmFtIHJlc291cmNlIC0gT3B0aW9uYWwgcmVzb3VyY2UgaWRlbnRpZmllclxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXV0aG9yaXplSWYoXG4gIGNvbmRpdGlvbjogYm9vbGVhbixcbiAgYXV0aENvbnRleHQ6IEF1dGhDb250ZXh0LFxuICBjYXBhYmlsaXR5OiBTeXN0ZW1DYXBhYmlsaXR5LFxuICByZXNvdXJjZT86IHN0cmluZ1xuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGlmIChjb25kaXRpb24pIHtcbiAgICBhd2FpdCByZXF1aXJlQ2FwYWJpbGl0eShjYXBhYmlsaXR5LCByZXNvdXJjZSkoYXV0aENvbnRleHQpO1xuICB9XG59XG5cbi8qKlxuICogQXV0aG9yaXphdGlvbiBjb250ZXh0IHZhbGlkYXRvclxuICogXG4gKiBAcGFyYW0gYXV0aENvbnRleHQgLSBDb250ZXh0IHRvIHZhbGlkYXRlXG4gKiBAdGhyb3dzIEVycm9yIGlmIGNvbnRleHQgaXMgaW52YWxpZFxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVBdXRoQ29udGV4dChhdXRoQ29udGV4dDogQXV0aENvbnRleHQpOiB2b2lkIHtcbiAgaWYgKCFhdXRoQ29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQXV0aENvbnRleHQgaXMgcmVxdWlyZWQnKTtcbiAgfVxuICBcbiAgaWYgKCFhdXRoQ29udGV4dC5pc0F1dGhlbnRpY2F0ZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VzZXIgbXVzdCBiZSBhdXRoZW50aWNhdGVkJyk7XG4gIH1cbiAgXG4gIGlmICghYXV0aENvbnRleHQudXNlcklkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVc2VyIElEIGlzIHJlcXVpcmVkJyk7XG4gIH1cbiAgXG4gIGlmICghYXV0aENvbnRleHQuc3lzdGVtUm9sZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignU3lzdGVtIHJvbGUgaXMgcmVxdWlyZWQnKTtcbiAgfVxufSJdfQ==