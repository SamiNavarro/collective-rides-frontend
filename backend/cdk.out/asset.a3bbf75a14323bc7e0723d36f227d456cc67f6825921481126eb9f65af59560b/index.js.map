{
  "version": 3,
  "sources": ["../../services/strava-integration-service/handlers/oauth/connect.ts", "../../shared/utils/lambda-utils.ts", "../../shared/auth/jwt-utils.ts", "../../shared/auth/auth-context.ts", "../../shared/utils/id-generator.ts"],
  "sourcesContent": ["import { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';\nimport { createResponse } from '../../../../shared/utils/lambda-utils';\nimport { getAuthContext } from '../../../../shared/auth/auth-context';\nimport { StravaConnectResponse } from '../../../../shared/types/strava';\nimport { generateId } from '../../../../shared/utils/id-generator';\n\nexport const handler = async (\n  event: APIGatewayProxyEvent\n): Promise<APIGatewayProxyResult> => {\n  try {\n    // Get auth context\n    const authContext = await getAuthContext(event);\n    \n    const clientId = process.env.STRAVA_CLIENT_ID;\n    const redirectUri = process.env.STRAVA_REDIRECT_URI;\n    \n    if (!clientId || !redirectUri) {\n      return createResponse(500, {\n        success: false,\n        error: 'Strava integration not configured'\n      });\n    }\n\n    // Generate secure state parameter\n    const state = generateId('strava_state');\n    \n    // Store state in session/cache for verification (implementation depends on session management)\n    // For now, we'll include the user ID in the state for verification\n    const secureState = `${state}:${authContext.userId}`;\n    \n    const authUrl = new URL('https://www.strava.com/oauth/authorize');\n    authUrl.searchParams.set('client_id', clientId);\n    authUrl.searchParams.set('redirect_uri', redirectUri);\n    authUrl.searchParams.set('response_type', 'code');\n    authUrl.searchParams.set('scope', 'read,activity:read');\n    authUrl.searchParams.set('state', secureState);\n\n    const response: StravaConnectResponse = {\n      authUrl: authUrl.toString(),\n      state: secureState\n    };\n\n    return createResponse(200, {\n      success: true,\n      data: response\n    });\n  } catch (error) {\n    console.error('Strava connect error:', error);\n    return createResponse(500, {\n      success: false,\n      error: error instanceof Error ? error.message : 'Failed to generate Strava connect URL'\n    });\n  }\n};", "/**\n * Lambda Utilities - Phase 1.2\n * \n * Utilities for Lambda function responses, error handling, and common\n * Lambda patterns.\n * \n * Compliance:\n * - Phase 1.2 Spec: .kiro/specs/phase-1.2.user-profile.v1.md\n */\n\nimport { APIGatewayProxyResult } from 'aws-lambda';\nimport { ApiResponse, ErrorResponse, HttpStatusCode, ApiErrorType } from '../types/api';\n\n/**\n * Get CORS headers based on the request origin\n * Supports both localhost and Vercel deployments\n */\nfunction getCorsHeaders(origin?: string): Record<string, string> {\n  // List of allowed origins (exact matches)\n  const allowedOrigins = [\n    'http://localhost:3000',\n    'http://127.0.0.1:3000',\n    'https://collective-rides-frontend.vercel.app',\n    'https://sydneycycles.com',\n    'https://collectiverides.com',\n  ];\n  \n  // Check if origin is allowed\n  let allowOrigin = 'http://localhost:3000'; // Default fallback\n  \n  if (origin) {\n    // Check exact match first\n    if (allowedOrigins.includes(origin)) {\n      allowOrigin = origin;\n    }\n    // Check for Vercel preview deployments (*.vercel.app)\n    else if (origin.endsWith('.vercel.app') && origin.startsWith('https://')) {\n      allowOrigin = origin;\n    }\n  }\n  \n  return {\n    'Content-Type': 'application/json',\n    'Access-Control-Allow-Origin': allowOrigin,\n    'Access-Control-Allow-Credentials': 'true',\n    'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,X-Amz-User-Agent',\n    'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS',\n  };\n}\n\n/**\n * Create a generic API response\n * \n * @param statusCode - HTTP status code\n * @param body - Response body\n * @param origin - Request origin for CORS\n * @returns API Gateway proxy result\n */\nexport function createResponse(\n  statusCode: number,\n  body: any,\n  origin?: string\n): APIGatewayProxyResult {\n  return {\n    statusCode,\n    headers: getCorsHeaders(origin),\n    body: JSON.stringify(body),\n  };\n}\n\n/**\n * Parse JSON from request body with error handling\n * \n * @param body - Request body string\n * @returns Parsed JSON object\n */\nexport function parseJSON<T>(body: string | null): T {\n  if (!body) {\n    throw new Error('Request body is required');\n  }\n  \n  try {\n    return JSON.parse(body) as T;\n  } catch (error) {\n    throw new Error('Invalid JSON in request body');\n  }\n}\n\n/**\n * Parse JSON from API Gateway event body\n * \n * @param event - API Gateway proxy event\n * @returns Parsed JSON object\n */\nexport function parseJsonBody<T>(event: { body: string | null }): T {\n  return parseJSON<T>(event.body);\n}\n\n/**\n * Create a successful API response\n * \n * @param data - Response data\n * @param statusCode - HTTP status code (default: 200)\n * @param origin - Request origin for CORS\n * @returns API Gateway proxy result\n */\nexport function createSuccessResponse<T>(\n  data: T,\n  statusCode: HttpStatusCode = HttpStatusCode.OK,\n  origin?: string\n): APIGatewayProxyResult {\n  const response: ApiResponse<T> = {\n    success: true,\n    data,\n    timestamp: new Date().toISOString(),\n  };\n  \n  return {\n    statusCode,\n    headers: getCorsHeaders(origin),\n    body: JSON.stringify(response),\n  };\n}\n\n/**\n * Create an error API response\n * \n * @param error - Error type\n * @param message - Error message\n * @param statusCode - HTTP status code\n * @param requestId - Optional request ID\n * @param origin - Request origin for CORS\n * @returns API Gateway proxy result\n */\nexport function createErrorResponse(\n  error: ApiErrorType | string,\n  message: string,\n  statusCode: HttpStatusCode,\n  requestId?: string,\n  origin?: string\n): APIGatewayProxyResult {\n  const response: ErrorResponse = {\n    error,\n    message,\n    timestamp: new Date().toISOString(),\n    requestId,\n  };\n  \n  return {\n    statusCode,\n    headers: getCorsHeaders(origin),\n    body: JSON.stringify(response),\n  };\n}\n\n/**\n * Create a validation error response\n * \n * @param message - Validation error message\n * @param requestId - Optional request ID\n * @returns API Gateway proxy result\n */\nexport function createValidationErrorResponse(\n  message: string,\n  requestId?: string\n): APIGatewayProxyResult {\n  return createErrorResponse(\n    ApiErrorType.VALIDATION_ERROR,\n    message,\n    HttpStatusCode.BAD_REQUEST,\n    requestId\n  );\n}\n\n/**\n * Create an unauthorized error response\n * \n * @param message - Error message (default: 'Unauthorized')\n * @param requestId - Optional request ID\n * @returns API Gateway proxy result\n */\nexport function createUnauthorizedResponse(\n  message: string = 'Unauthorized',\n  requestId?: string\n): APIGatewayProxyResult {\n  return createErrorResponse(\n    ApiErrorType.UNAUTHORIZED,\n    message,\n    HttpStatusCode.UNAUTHORIZED,\n    requestId\n  );\n}\n\n/**\n * Create a forbidden error response\n * \n * @param message - Error message (default: 'Forbidden')\n * @param requestId - Optional request ID\n * @returns API Gateway proxy result\n */\nexport function createForbiddenResponse(\n  message: string = 'Forbidden',\n  requestId?: string\n): APIGatewayProxyResult {\n  return createErrorResponse(\n    ApiErrorType.FORBIDDEN,\n    message,\n    HttpStatusCode.FORBIDDEN,\n    requestId\n  );\n}\n\n/**\n * Create a not found error response\n * \n * @param message - Error message (default: 'Not found')\n * @param requestId - Optional request ID\n * @returns API Gateway proxy result\n */\nexport function createNotFoundResponse(\n  message: string = 'Not found',\n  requestId?: string\n): APIGatewayProxyResult {\n  return createErrorResponse(\n    ApiErrorType.NOT_FOUND,\n    message,\n    HttpStatusCode.NOT_FOUND,\n    requestId\n  );\n}\n\n/**\n * Create an internal server error response\n * \n * @param message - Error message (default: 'Internal server error')\n * @param requestId - Optional request ID\n * @returns API Gateway proxy result\n */\nexport function createInternalErrorResponse(\n  message: string = 'Internal server error',\n  requestId?: string\n): APIGatewayProxyResult {\n  return createErrorResponse(\n    ApiErrorType.INTERNAL_ERROR,\n    message,\n    HttpStatusCode.INTERNAL_SERVER_ERROR,\n    requestId\n  );\n}\n\n/**\n * Handle Lambda function errors and convert to appropriate HTTP responses\n * \n * @param error - Error object\n * @param requestId - Request ID for logging\n * @returns API Gateway proxy result\n */\nexport function handleLambdaError(error: unknown, requestId?: string): APIGatewayProxyResult {\n  console.error('Lambda error:', error, { requestId });\n  \n  if (error instanceof Error) {\n    const message = error.message;\n    \n    // Map specific error messages to HTTP status codes\n    if (message.includes('Authentication required') || message.includes('JWT')) {\n      return createUnauthorizedResponse(message, requestId);\n    }\n    \n    if (message.includes('privileges required') || message.includes('Forbidden')) {\n      return createForbiddenResponse(message, requestId);\n    }\n    \n    if (message.includes('not found') || message.includes('Not found')) {\n      return createNotFoundResponse(message, requestId);\n    }\n    \n    if (message.includes('validation') || message.includes('Invalid')) {\n      return createValidationErrorResponse(message, requestId);\n    }\n  }\n  \n  // Default to internal server error\n  return createInternalErrorResponse('An unexpected error occurred', requestId);\n}\n\n/**\n * Log structured information for CloudWatch\n * \n * @param level - Log level\n * @param message - Log message\n * @param context - Additional context\n */\nexport function logStructured(\n  level: 'INFO' | 'WARN' | 'ERROR',\n  message: string,\n  context: Record<string, any> = {}\n): void {\n  const logEntry = {\n    timestamp: new Date().toISOString(),\n    level,\n    message,\n    ...context,\n  };\n  \n  console.log(JSON.stringify(logEntry));\n}", "/**\n * JWT Utilities - Phase 1.2\n * \n * Utilities for extracting JWT claims from API Gateway events.\n * Note: JWT signature validation is handled by API Gateway + Cognito Authorizer.\n * This module only extracts claims from the validated context.\n * \n * Compliance:\n * - Phase 1.2 Spec: .kiro/specs/phase-1.2.user-profile.v1.md\n * - AWS Architecture: .kiro/specs/architecture.aws.v1.md\n */\n\nimport { JwtClaims, ApiGatewayAuthorizerContext } from '../types/auth';\n\n/**\n * Extract JWT claims from API Gateway authorizer context\n * \n * @param authorizerContext - API Gateway authorizer context\n * @returns JWT claims object\n * @throws Error if claims are missing or invalid\n */\nexport function extractJwtClaims(authorizerContext: ApiGatewayAuthorizerContext): JwtClaims {\n  const { claims } = authorizerContext;\n  \n  if (!claims) {\n    throw new Error('No JWT claims found in authorizer context');\n  }\n  \n  // Validate required claims\n  if (!claims.sub) {\n    throw new Error('Missing required claim: sub');\n  }\n  \n  if (!claims.email) {\n    throw new Error('Missing required claim: email');\n  }\n  \n  if (!claims.iat) {\n    throw new Error('Missing required claim: iat');\n  }\n  \n  if (!claims.exp) {\n    throw new Error('Missing required claim: exp');\n  }\n  \n  // Convert timestamps to numbers (API Gateway formats them as date strings)\n  let iat: number;\n  let exp: number;\n  \n  if (typeof claims.iat === 'string') {\n    // Check if it's a Unix timestamp string or a formatted date string\n    if (/^\\d+$/.test(claims.iat)) {\n      iat = parseInt(claims.iat, 10);\n    } else {\n      // Parse formatted date string\n      iat = Math.floor(new Date(claims.iat).getTime() / 1000);\n    }\n  } else {\n    iat = Number(claims.iat);\n  }\n  \n  if (typeof claims.exp === 'string') {\n    // Check if it's a Unix timestamp string or a formatted date string\n    if (/^\\d+$/.test(claims.exp)) {\n      exp = parseInt(claims.exp, 10);\n    } else {\n      // Parse formatted date string\n      exp = Math.floor(new Date(claims.exp).getTime() / 1000);\n    }\n  } else {\n    exp = Number(claims.exp);\n  }\n  \n  if (isNaN(iat) || isNaN(exp)) {\n    throw new Error('Invalid timestamp claims');\n  }\n  \n  // Check if token is expired (additional safety check)\n  const now = Math.floor(Date.now() / 1000);\n  if (exp < now) {\n    throw new Error('JWT token has expired');\n  }\n  \n  return {\n    sub: claims.sub,\n    email: claims.email,\n    iat,\n    exp,\n    iss: claims.iss || '',\n    aud: claims.aud || '',\n    'custom:system_role': claims['custom:system_role'],\n  };\n}\n\n/**\n * Extract user ID from JWT claims\n * \n * @param claims - JWT claims\n * @returns User ID (Cognito sub)\n */\nexport function getUserIdFromClaims(claims: JwtClaims): string {\n  return claims.sub;\n}\n\n/**\n * Extract email from JWT claims\n * \n * @param claims - JWT claims\n * @returns Email address\n */\nexport function getEmailFromClaims(claims: JwtClaims): string {\n  return claims.email;\n}\n\n/**\n * Extract system role from JWT claims\n * \n * @param claims - JWT claims\n * @returns System role or 'User' as default\n */\nexport function getSystemRoleFromClaims(claims: JwtClaims): 'User' | 'SiteAdmin' {\n  const customRole = claims['custom:system_role'];\n  \n  // Validate and return system role, default to 'User'\n  if (customRole === 'SiteAdmin') {\n    return 'SiteAdmin';\n  }\n  \n  return 'User';\n}", "/**\n * Authentication Context - Phase 1.2\n * \n * Utilities for creating and managing user authentication context\n * from API Gateway events.\n * \n * Compliance:\n * - Phase 1.2 Spec: .kiro/specs/phase-1.2.user-profile.v1.md\n * - AWS Architecture: .kiro/specs/architecture.aws.v1.md\n */\n\nimport { APIGatewayProxyEvent } from 'aws-lambda';\nimport { AuthContext, LambdaRequestContext } from '../types/auth';\nimport { SystemRole } from '../types/user';\nimport { extractJwtClaims, getUserIdFromClaims, getEmailFromClaims, getSystemRoleFromClaims } from './jwt-utils';\n\n/**\n * Get authentication context from API Gateway event\n * \n * @param event - API Gateway proxy event\n * @returns Authentication context\n */\nexport async function getAuthContext(event: APIGatewayProxyEvent): Promise<AuthContext> {\n  return createAuthContext(event.requestContext as LambdaRequestContext);\n}\n\n/**\n * Create authentication context from Lambda event request context\n * \n * @param requestContext - Lambda request context from API Gateway\n * @returns Authentication context\n * @throws Error if authentication context cannot be created\n */\nexport function createAuthContext(requestContext: LambdaRequestContext): AuthContext {\n  // Check if authorizer context exists (user is authenticated)\n  if (!requestContext.authorizer) {\n    return {\n      userId: '',\n      email: '',\n      systemRole: SystemRole.USER,\n      isAuthenticated: false,\n      isSiteAdmin: false,\n    };\n  }\n  \n  try {\n    // Extract JWT claims from API Gateway authorizer context\n    const claims = extractJwtClaims(requestContext.authorizer);\n    \n    // Extract user information\n    const userId = getUserIdFromClaims(claims);\n    const email = getEmailFromClaims(claims);\n    \n    // Note: systemRole is determined from database, not JWT claims\n    // This allows for real-time role changes without re-authentication\n    const systemRole = SystemRole.USER; // Default, will be updated by service layer\n    \n    return {\n      userId,\n      email,\n      systemRole,\n      isAuthenticated: true,\n      isSiteAdmin: false, // Will be updated by service layer\n    };\n  } catch (error) {\n    throw new Error(`Failed to create auth context: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n}\n\n/**\n * Create enhanced authentication context with database-sourced role information\n * \n * @param requestContext - Lambda request context from API Gateway\n * @param userRepository - User repository for fetching current role\n * @returns Enhanced authentication context with current systemRole\n */\nexport async function createEnhancedAuthContext(\n  requestContext: LambdaRequestContext, \n  userRepository: { getUserById: (id: string) => Promise<{ systemRole: SystemRole } | null> }\n): Promise<AuthContext> {\n  const baseContext = createAuthContext(requestContext);\n  \n  if (!baseContext.isAuthenticated) {\n    return baseContext;\n  }\n  \n  try {\n    // Fetch current user data from database to get accurate systemRole\n    const userData = await userRepository.getUserById(baseContext.userId);\n    \n    if (userData) {\n      return {\n        ...baseContext,\n        systemRole: userData.systemRole,\n        isSiteAdmin: userData.systemRole === SystemRole.SITE_ADMIN,\n      };\n    }\n    \n    return baseContext;\n  } catch (error) {\n    // If database lookup fails, return base context with default role\n    return baseContext;\n  }\n}\n\n/**\n * Validate that user is authenticated\n * \n * @param authContext - Authentication context\n * @throws Error if user is not authenticated\n */\nexport function requireAuthentication(authContext: AuthContext): void {\n  if (!authContext.isAuthenticated) {\n    throw new Error('Authentication required');\n  }\n}\n\n/**\n * Validate that user is a site administrator\n * \n * @param authContext - Authentication context\n * @throws Error if user is not a site administrator\n */\nexport function requireSiteAdmin(authContext: AuthContext): void {\n  requireAuthentication(authContext);\n  \n  if (!authContext.isSiteAdmin) {\n    throw new Error('Site administrator privileges required');\n  }\n}\n\n/**\n * Check if user can access another user's profile\n * \n * @param authContext - Authentication context\n * @param targetUserId - ID of the user being accessed\n * @returns True if access is allowed\n */\nexport function canAccessUser(authContext: AuthContext, targetUserId: string): boolean {\n  if (!authContext.isAuthenticated) {\n    return false;\n  }\n  \n  // Users can access their own profile\n  if (authContext.userId === targetUserId) {\n    return true;\n  }\n  \n  // Site admins can access any profile\n  if (authContext.isSiteAdmin) {\n    return true;\n  }\n  \n  return false;\n}\n\n/**\n * Check if user can modify another user's profile\n * \n * @param authContext - Authentication context\n * @param targetUserId - ID of the user being modified\n * @returns True if modification is allowed\n */\nexport function canModifyUser(authContext: AuthContext, targetUserId: string): boolean {\n  return canAccessUser(authContext, targetUserId);\n}\n\n/**\n * Check if user can modify system role\n * \n * @param authContext - Authentication context\n * @returns True if system role modification is allowed\n */\nexport function canModifySystemRole(authContext: AuthContext): boolean {\n  return authContext.isSiteAdmin;\n}\n\n/**\n * Validate authentication context from API Gateway event\n * \n * @param event - API Gateway proxy event\n * @returns Authentication context\n * @throws Error if user is not authenticated\n */\nexport function validateAuthContext(event: APIGatewayProxyEvent): AuthContext {\n  const authContext = createAuthContext(event.requestContext as LambdaRequestContext);\n  \n  if (!authContext.isAuthenticated) {\n    throw new Error('Authentication required');\n  }\n  \n  return authContext;\n}", "import { randomBytes } from 'crypto';\n\nexport function generateId(prefix: string): string {\n  const timestamp = Date.now().toString(36);\n  const random = randomBytes(6).toString('hex');\n  return `${prefix}_${timestamp}_${random}`;\n}"],
  "mappings": "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",
  "names": ["connect_exports", "__export", "handler", "__toCommonJS", "getCorsHeaders", "origin", "allowedOrigins", "allowOrigin", "createResponse", "statusCode", "body", "extractJwtClaims", "authorizerContext", "claims", "iat", "exp", "now", "getUserIdFromClaims", "getEmailFromClaims", "getAuthContext", "event", "createAuthContext", "requestContext", "claims", "extractJwtClaims", "userId", "getUserIdFromClaims", "email", "getEmailFromClaims", "systemRole", "error", "import_crypto", "generateId", "prefix", "timestamp", "random", "handler", "event", "authContext", "getAuthContext", "clientId", "redirectUri", "createResponse", "secureState", "generateId", "authUrl", "response", "error"]
}
